#pragma kernel CSMain

#pragma multi_compile MANDELBROT BURNING_SHIP MANDEL3 MANDEL4

#pragma multi_compile Q_VERY_LOW Q_LOW Q_MED Q_HIGH Q_VERY_HIGH Q_ULTRA Q_ULTRA_HIGH Q_SUPER Q_MEGA Q_SUPER_MEGA

#pragma multi_compile BARE DIST

#pragma multi_compile JULIA NORMAL
//TODO: THIS SHADER LACKS PROPER DERIVETIVE AND DISTANCE ESTIMATION BSC IT DOES'T YET SUPPORT FLOATS

#if Q_VERY_LOW
#define PRECISION 4
#elif Q_LOW
#define PRECISION 6
#elif Q_MED
#define PRECISION 8
#elif Q_HIGH
#define PRECISION 10
#elif Q_VERY_HIGH
#define PRECISION 12
#elif Q_ULTRA
#define PRECISION 14
#elif Q_ULTRA_HIGH
#define PRECISION 16
#elif Q_SUPER
#define PRECISION 18
#elif Q_MEGA
#define PRECISION 20
#elif Q_SUPER_MEGA
#define PRECISION 24
#endif

#include "Assets/Shaders/General/fpnum.cginc"

RWTexture2D<float4> Result;

float2 _PixelOffset;

uint _MaxIter;
uint _IterPerCycle = 5;
int _BailoutRadius;
int _BailoutRadiusSQ;

StructuredBuffer<int> _DataBuffer;
static const int MiddleX = 0;
static const int MiddleY = PRECISION;
static const int Scale = PRECISION * 2;
static const int JuliaX = PRECISION * 3;
static const int JuliaY = PRECISION * 4;


static const int CurX = 0;
static const int CurY = PRECISION;

#if DIST
static const int DerX = 2 * PRECISION;
static const int DerY = 3 * PRECISION;
static const int iter = 4 * PRECISION;
static const int finished = 4 * PRECISION + 1;
static const int iterOffset = 4 * PRECISION + 2;
static const int angle = 4 * PRECISION + 3;
static const int distance = 4 * PRECISION + 4;
static const int PixelSize = 4 * PRECISION + 5;

#else
static const int iter = 2 * PRECISION;
static const int finished = 2 * PRECISION + 1;
static const int iterOffset = 2 * PRECISION + 2;
static const int angle = 2 * PRECISION + 3;
static const int distance = 2 * PRECISION + 4;
static const int PixelSize = 2 * PRECISION + 5;

#endif



uint _RenderWidth;
int _FrankensteinOffsetX;
int _FrankensteinOffsetY;

int _ShiftX;
int _ShiftY;

uint _Register;

RWStructuredBuffer<int> _MultiFrameData;

bool _reset;




struct res {
	uint iter;
	bool finished;
	float offset;
	float angle;
	float distance;
	float normX;
	float normY;
};
RWStructuredBuffer<res> _IterBuffer;


//Returning float falue as a int allows me to store all the values in one int array, the value is later converted back to float
int getOffset(float2 squares) {
	float logz = log(squares.x + squares.y) / 2.0;
	float res = log(logz / log(_BailoutRadius));
#if MANDELBROT || BURNING_SHIP
	res /= log(2.0);
#elif MANDEL3
	res /= log(3.0);
#elif MANDEL4
	res /= log(4.0);
#endif
	res = clamp(res, 0.0, 1.0) ;
	return asint(res);
}
uint getIter(uint2 pixel, uint width, uint height, uint idx) {
	digits cX;
	digits cY;
	digits zX;
	digits zY;
	digits squareX;
	digits squareY;
	digits scale;
	digits offset;
	digits middle;
#if DIST
	double dzX;
	double dzY;
	//digits dzX;
	//digits dzY;
#endif
	//Initialize values
	[unroll]
	for (int j = 0; j < PRECISION; j++) {
#if JULIA
		if (_MultiFrameData[idx + iter] > 0) {
			zX.digits[j] = _MultiFrameData[idx + CurX + j];
			zY.digits[j] = _MultiFrameData[idx + CurY + j];
		}
#else

		zX.digits[j] = _MultiFrameData[idx + CurX + j];
		zY.digits[j] = _MultiFrameData[idx + CurY + j];
#endif
#if DIST


		//This is how it was
		//dzX.digits[j] = _MultiFrameData[idx + DerX + j];
		//dzY.digits[j] = _MultiFrameData[idx + DerY + j];
#endif
		scale.digits[j] = _DataBuffer[Scale + j];
		offset.digits[j] = 0;
	}

#if DIST
	//hack
	dzX = asdouble(asuint(_MultiFrameData[idx + DerX]), asuint(_MultiFrameData[idx + DerX + 1]));
	dzY = asdouble(asuint(_MultiFrameData[idx + DerY]),asuint( _MultiFrameData[idx + DerY + 1]));

#endif
#if JULIA
	if (_MultiFrameData[idx + iter] == 0) {
		//Initialize values from cpu
		offset.digits[0] = pixel.x - width / 2;
		offset = multiply(add(offset, setDouble((double)_PixelOffset.x)), scale);
		[unroll]
		for (int a = 0; a < PRECISION; a++) {
			middle.digits[a] = _DataBuffer[MiddleX + a];
		}
		zX = add(offset, middle);
		for (int b = 0; b < PRECISION; b++) {
			offset.digits[b] = 0;
		}
		offset.digits[0] = pixel.y - height / 2;
		offset = multiply(add(offset, setDouble((double)_PixelOffset.y)), scale);
		[unroll]
		for (int c = 0; c < PRECISION; c++) {
			middle.digits[c] = _DataBuffer[MiddleY + c];
		}
		zY = add(offset, middle);
		//Turned out the image was flipped this was added to reflip it
		//It might have introduced some hidden bugs
		zY = Negate(zY);
	}
	[unroll]
	for (int g = 0; g < PRECISION; g++) {
		cX.digits[g] = _DataBuffer[JuliaX + g];
		cY.digits[g] = _DataBuffer[JuliaY + g];
	}

#else
	//Initialize values from cpu
	offset.digits[0] = pixel.x - width / 2;
	offset = multiply(add(offset, setDouble((double)_PixelOffset.x)), scale);
	[unroll]
	for (int a = 0; a < PRECISION; a++) {
		middle.digits[a] = _DataBuffer[MiddleX + a];
	}
	cX = add(offset, middle);
	for (int b = 0; b < PRECISION; b++) {
		offset.digits[b] = 0;
	}
	offset.digits[0] = pixel.y - height / 2;
	offset = multiply(add(offset, setDouble((double)_PixelOffset.y)), scale);
	[unroll]
	for (int c = 0; c < PRECISION; c++) {
		middle.digits[c] = _DataBuffer[MiddleY + c];
	}
	cY = add(offset, middle);
	//Turned out the image was flipped this was added to reflip it
	//It might have introduced some hidden bugs
	cY = Negate(cY);
#endif
	int iter = 0;
	squareX = square(zX);
	squareY = square(zY);
	[fastopt]
	for (uint i = 0; i < _IterPerCycle; i++) {


//This part is responsibe for calculationg iteration insert new fractals here
#if MANDELBROT
#if DIST
		//turned out I need to implent floating point numbers in order to represent the derivative ( it is not confined to range close to 1)
		// as a hack I do all the calulations on double.

		//this is how it was
		//complex zComp;
		//zComp.x = zX;
		//zComp.y = zY;
		//complex dzComp;
		//dzComp.x = dzX;
		//dzComp.y = dzY;
		//complex temp = mulComplex(zComp, dzComp);
		//dzX = add(intMul(temp.x,2), setDouble(1.0));
		//dzY =intMul( temp.y,2);
		

		//hack
		double temp = 2 * (dzX * toDouble(zX) - dzY * toDouble(zY)) + 1.0;
		dzY = 2 * (dzX * toDouble(zY) + dzY * toDouble(zX));
		dzX = temp;

#endif

		zY = add(cY, multiply(add(zX,zX), zY));
		zX = add(subtract(squareX, squareY), cX);
#elif BURNING_SHIP
		zY = add(cY, abs(multiply(add(zX, zX), zY)));
		zX = add(subtract(squareX, squareY), cX);
#elif MANDEL3 
// Not the optimal way but it is simple to write down
// TODO: unroll it and reduce the amount of multiplications
		complex z;
		z.x = zX;
		z.y = zY;
		z = mulComplex(mulComplex(z, z), z);
		zX = add(z.x, cX);
		zY = add(z.y, cY);
#elif MANDEL4
		complex z;
		z.x = zX;
		z.y = zY;
		z = mulComplex(mulComplex(z, z), mulComplex(z, z));
		zX = add(z.x, cX);
		zY = add(z.y, cY);
#endif

		squareX = square(zX);
		squareY = square(zY);
		iter++;


		if (!inBounds(squareX, squareY, _BailoutRadiusSQ)) {
			_MultiFrameData[idx + iterOffset] = getOffset(float2(toFloat(squareX), toFloat(squareY)));
			_MultiFrameData[idx + angle] = asint(atan2(toFloat(zY),toFloat(zX)));
#if DIST
			double2 zf = float2(toDouble(zX), toDouble(zY));
			double2 dzf = float2(dzX, dzY);
			double d = 0.5 * sqrt(dot(zf, zf) / dot(dzf, dzf)) * log(dot(zf, zf));
			_MultiFrameData[idx + distance] = asint((float)(d / toFloat(scale)));
			/*float zMag2 = toFloat(squareX) + toFloat(squareY);
			float dzMag2 = toFloat(dzX) * toFloat(dzX) + toFloat(dzY) * toFloat(dzY);
			_MultiFrameData[idx + distance] = asint(0.5 * sqrt(zMag2 / dzMag2) * log(zMag2)/toFloat(scale));*/
#else
			_MultiFrameData[idx + distance] = asint(1000000.0); // this makes it so that if the distance estimation is turned of the image is not fully black
#endif
			_MultiFrameData[idx + finished] = true;
			return iter;
		}
	}

	//They are in separate loop bcs I read somewhrer online some time ago that this is faster
	//Should verify the claim
	for (int l = 0; l < PRECISION; l++) {
		_MultiFrameData[idx + CurX + l] = zX.digits[l];
	}
	for (int k = 0; k < PRECISION; k++) {
		_MultiFrameData[idx + CurY + k] = zY.digits[k];
	}

//This is how it was
//#if DIST
//	for (int m = 0; m < PRECISION; m++) {
//		_MultiFrameData[idx + DerX + m] = dzX.digits[m];
//	}
//	for (int n = 0; n < PRECISION; n++) {
//		_MultiFrameData[idx + DerY + n] = dzY.digits[n];
//	}
//#endif
	
	//hack
#if DIST
	uint tderx1, tderx2, tdery1, tdery2;
	asuint(dzX,tderx1,tderx2);
	asuint(dzY,tdery1,tdery2);
	_MultiFrameData[idx + DerX] =asint(tderx1);
	_MultiFrameData[idx + DerX+1] = asint(tderx2);
	_MultiFrameData[idx + DerY] = asint(tdery1);
	_MultiFrameData[idx + DerY + 1] = asint(tdery2);
#endif

	return iter;


}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

	uint width, height;
	Result.GetDimensions(width, height);
	
	_BailoutRadiusSQ = _BailoutRadius * _BailoutRadius;
	
	uint basePixelId = id.x + id.y * width + width * height * _Register;

	uint pixelId = basePixelId * PixelSize;

	int currentIter = 0;

	//check if further computatuin is nesesary
	if (!_MultiFrameData[pixelId + finished]) {
		currentIter = getIter(id.xy, width, height, pixelId);

		_MultiFrameData[pixelId + iter] += currentIter;
		if ((uint)_MultiFrameData[pixelId + iter] >= _MaxIter) {
			_MultiFrameData[pixelId + finished] = true;
		}


	}
	int iterId = id.x + _FrankensteinOffsetX + (id.y + _FrankensteinOffsetY) * _RenderWidth;

	_IterBuffer[iterId].iter = _MultiFrameData[pixelId + iter];
	_IterBuffer[iterId].finished = _MultiFrameData[pixelId + finished];
	_IterBuffer[iterId].offset = asfloat(_MultiFrameData[pixelId + iterOffset]);
	_IterBuffer[iterId].angle = asfloat(_MultiFrameData[pixelId + angle]) ;
	_IterBuffer[iterId].distance = asfloat(_MultiFrameData[pixelId + distance]);


}
