// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
int _PixelWidth;
struct res {
	uint iter;
	bool finished;
};
RWStructuredBuffer<res> _IterBuffer;
uint _MaxIter;


int _ColorArrayLength;
StructuredBuffer<float4> _Colors;
bool _Sigmoid;
int _ColorStrength;
float sigmoid(float x) {
	return(exp(x) / (1.0 + exp(x)));
}
float pow(float x, int exp) {
	float res = x;
	for (int i = 0; i < exp - 1; i++) {
		res *= x;
	}
	return res;
}
float4 getColor(res res) {
	float4 InColor = float4(0.0, 0.0, 0.0, 1.0f);


	if (!res.finished || res.iter >= _MaxIter) {
		return InColor;
	}
	if (res.iter == 0) {
		res.iter = 1;
	}
	float baseRatio = (float)res.iter / (_ColorStrength);
	int baseColorIdx = (int)(floor(baseRatio) % _ColorArrayLength);
	int upColorIdx = (int)((floor(baseRatio) + 1) % _ColorArrayLength);
	float ratio = baseRatio % 1;
	if (_Sigmoid) {
		float red = _Colors[baseColorIdx].x + (_Colors[upColorIdx].x - _Colors[baseColorIdx].x) * sigmoid(20 * ratio - 5);
		float green = _Colors[baseColorIdx].y + (_Colors[upColorIdx].y - _Colors[baseColorIdx].y) * sigmoid(20 * ratio - 10);
		float blue = _Colors[baseColorIdx].z + (_Colors[upColorIdx].z - _Colors[baseColorIdx].z) * sigmoid(20 * ratio - 15);
		return float4(red, green, blue, 1.0);
	}
	else {
		return float4(_Colors[baseColorIdx] + (_Colors[upColorIdx] - _Colors[baseColorIdx]) * (-2.0 * pow(ratio, 3) + 3.0 * pow(ratio, 2)));
	}

	 
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint width, height;
	Result.GetDimensions(width, height);
	
	int textureX = id.x / _PixelWidth;
	int textureY = id.y / _PixelWidth;
	int textureIdx = textureX + textureY * (width/ _PixelWidth);

    Result[id.xy] = getColor(_IterBuffer[textureIdx]);
	
}
