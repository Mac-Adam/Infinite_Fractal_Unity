// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
int _PixelWidth;
struct res {
	uint iter;
	bool finished;
};
RWStructuredBuffer<res> _IterBuffer;
uint _MaxIter;

bool _Log;
int _ColorStrength;

float4 getColor(res res) {
	float4 InColor = float4(0.31, 0.427, 0.478, 1.0f);
	float4 Colors[5];

	Colors[0] = float4(0.086, 0.376, 0.533, 1.0);
	Colors[1] = float4(0.29, 0.435, 0.647, 1.0);
	Colors[2] = float4(0.753, 0.839, 0.875, 1.0);
	Colors[3] = float4(0.859, 0.529, 0.239, 1.0);
	Colors[4] = float4(0.71, 0.098, 0.525, 1.0);


	if (!res.finished || res.iter >= _MaxIter) {
		return InColor;
	}
	if (res.iter == 0) {
		res.iter = 1;
	}
	float ratio;
	if (_Log) {
		ratio = log(res.iter) / log(_ColorStrength);
	}
	else {
		ratio = (float)res.iter / (_ColorStrength * 10.0);
	}
	
	
	int baseColorIdx = (int)(floor(ratio) % 5);
	int upColorIdx = (int)((floor(ratio) + 1) % 5);
	return float4(Colors[baseColorIdx] + (Colors[upColorIdx] - Colors[baseColorIdx]) * (ratio % 1));




}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint width, height;
	Result.GetDimensions(width, height);

	int textureX = id.x / _PixelWidth;
	int textureY = id.y / _PixelWidth;
	int textureIdx = textureX + textureY * (width/ _PixelWidth);

    Result[id.xy] = getColor(_IterBuffer[textureIdx]);
	
}
